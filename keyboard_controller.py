import time
import random

try:  # pragma: no cover - optional dependency
    from pynput.keyboard import Controller, Key
except Exception:  # pragma: no cover
    Controller = None  # type: ignore[assignment]

    class Key:  # type: ignore[dead-code]
        """Fallback ``Key`` placeholder when ``pynput`` is missing."""
        pass


class _NoopController:
    """Minimal stand in for :class:`pynput.keyboard.Controller`.

    When ``pynput`` is not installed the public ``KeyboardController`` will
    still be importable but its methods become no-ops.
    """

    def press(self, key):
        pass

    def release(self, key):
        pass

    def pressed(self, *keys):
        class _DummyCtx:
            def __enter__(self):  # pragma: no cover - simple no-op
                pass

            def __exit__(self, exc_type, exc, tb):  # pragma: no cover
                return False

        return _DummyCtx()

# ``KeyboardController`` emits global keyboard events which we also monitor to
# detect manual user input.  The module keeps a timestamp of the most recent
# event generated by the controller so listeners can ignore those events.
_last_generated = 0.0


def _mark_generated() -> None:
    global _last_generated
    _last_generated = time.time()


def is_app_generated() -> bool:
    """Return ``True`` if a keyboard event was generated by this module."""
    return time.time() - _last_generated < 0.5

# Mapping for synonymous key names.  The `Key` enum from pynput exposes
# attributes such as ``Key.enter`` or ``Key.cmd``.  Rather than maintain a
# large lookup table of every supported key we only provide aliases for the few
# names that differ from the attribute on ``Key`` and fall back to the provided
# string if no attribute exists.
_ALIASES = {
    "command": "cmd",
}


class KeyboardController:
    """Wrapper around ``pynput``'s Controller providing simple key helpers.

    If ``pynput`` is not available the controller becomes a no-op so that
    callers can still import and instantiate this class without the optional
    dependency.
    """

    def __init__(self):
        self._controller = Controller() if Controller else _NoopController()

    def _to_key(self, key: str):
        """Map ``key`` name to ``pynput``'s ``Key`` or return raw value.

        ``pynput`` exposes its special keys in lowercase (e.g. ``Key.enter``),
        but callers may supply names in any case.  Normalise the incoming name
        to lowercase before resolving aliases and looking up the ``Key``
        attribute so that ``"CTRL"``, ``"Ctrl"`` and ``"ctrl"`` all refer to
        the same key.
        """

        key_norm = key.lower()
        key_norm = _ALIASES.get(key_norm, key_norm)
        return getattr(Key, key_norm, key_norm)

    def _sleep_with_jitter(self, interval: float, jitter: float) -> None:
        """Sleep for ``interval`` seconds applying ``jitter`` variation."""

        if not interval:
            return

        delay = interval
        if jitter:
            delay += random.uniform(-jitter, jitter)
            if delay < 0:
                delay = 0
        time.sleep(delay)

    def press(self, key: str, delay: float = 0.0) -> None:
        """Press and release ``key``.

        Parameters
        ----------
        key:
            Name of the key to press.  Values that match attributes on
            ``pynput.keyboard.Key`` will be converted automatically, otherwise
            the raw string is forwarded.
        delay:
            Optional delay in seconds to wait after the key is released.  A
            small delay can improve reliability on some platforms and allows
            more precise timing when sending a series of key presses.
        """

        k = self._to_key(key)
        _mark_generated()
        self._controller.press(k)
        self._controller.release(k)
        if delay:
            time.sleep(delay)

    def hotkey(self, *keys: str) -> None:
        mapped = [self._to_key(k) for k in keys]
        # ``Controller.pressed`` is not guaranteed to exist on the object
        # assigned to ``_controller`` (tests replace it with a simple dummy
        # object).  Fall back to manually pressing and releasing the keys if the
        # helper is missing.
        if hasattr(self._controller, "pressed"):
            _mark_generated()
            with self._controller.pressed(*mapped):
                pass
        else:
            for k in mapped:
                _mark_generated()
                self._controller.press(k)
            for k in reversed(mapped):
                _mark_generated()
                self._controller.release(k)

    def typewrite(
        self,
        text: str,

        interval: float = 0.2,
        miss_chance: float = 0.0,
        jitter: float = 0.1,

    ) -> None:
        """Type ``text`` character by character.

        Parameters
        ----------
        text:
            Text to type.
        interval:

            Base delay between key presses.  Defaults to ``0.2`` seconds for
            a noticeably slow typing speed.
        miss_chance:
            Probability in the range ``[0.0, 1.0]`` that a temporary
            correction is performed.  When triggered the character is typed,
            deleted using backspace and then typed again so the final output
            still contains the original text.
        jitter:
            Additional random variation added to ``interval``.  Each delay is
            adjusted by ``random.uniform(-jitter, jitter)`` so successive
            keystrokes are unevenly spaced.  Ignored if ``interval`` is ``0``.
        """

        miss_chance = max(0.0, min(1.0, miss_chance))

        for ch in text:
            if miss_chance and random.random() < miss_chance:
                self.press(ch)
                self._sleep_with_jitter(interval, jitter)
                self.press("backspace")
                self._sleep_with_jitter(interval, jitter)
            self.press(ch)
            self._sleep_with_jitter(interval, jitter)
